= Primary Keys

include::../includes/attributes.adoc[]

Most entities that are stored in the database have a primary key.
Once assigned, the primary key cannot be (should not be) modified.
In the rare case that an entity does not have a primary key it is recommended that an autogenerated key is added to the table as it would improve the retrieval and update times of records in the table.

== Primary keys

Every entity in the stored is uniquely identified (and can be retrieved from the database) by the combination of its type and its primary key.
Primary key values are unique per entity class.
Instances of different entity classes, however, may share the same primary key value.

Only entity objects have primary keys.
Instances of other xref:entities/JPA Persistable Types.adoc[persistable types] are always stored as part of their containing entity objects and do not have their own separate identity.

[TIP]
The entity must have a primary key to search for a row in the database using the EntityManager find() and refresh() methods.

== Autogenerated Primary Keys

Identifiers represent the primary key of an entity.
This implies that the values are unique and can identify a specific entity, that they aren't null and won't be modified.

In addition to the `@Id` annotation, you could also add the `@GeneratedValue` to signal to the entity manager that the field will be set later by a downstream process relaxing the not null rule.

Fields that have the `@Id` tag but *not* `@GeneratedValue` cannot be null, and will the EntityManager generate an error if you try and persist it.

The attributes of the `@GeneratedValue` are ignored, and will {product-name} assumed that the strategy will always be sequencing and that the database generates it.

[source,java]
----
@Entity
public class Project {
    @Id @GeneratedValue
    private long id; // still set automatically
    //...
}
----

== Composite primary keys

A composite primary key consists of multiple primary key fields.
Each primary key field must be one of the supported types listed above.

For example, the primary key of the following Project entity class consists of two fields:

[source,java]
----
@Entity
@IdClass(ProductId.class)
public class Product {
    @Id
    private int departmentId;
    @Id
    private long productId;
    //...
}
----

When an entity has multiple primary key fields, JPA requires defining a special ID class that is attached to the entity class using the `@IdClass` annotation.
The ID class reflects the primary key fields and its objects can represent primary key values:

[source,java]
----
public class ProductId {
    int departmentId;
	long productId;
}
----

[IMPORTANT]
{product-name} requires and enforce use if either ID classes or and Embedded primary Key

== Embedded Primary Key

The recommended way to represent a composite primary key is to use an embeddable class:

[source,java]
----
@Entity
public class Product {
    @EmbeddedId
    private ProductId id;
    //...
}

@Embeddable
public class ProductId {
    @Column(name="DEPT", nullable=false)
    int departmentId;
    @Column(name="PRODID", nullable=false)
    long productId;
}
----

The primary key fields are defined in an xref:entities/JPA Persistable Types.adoc#Embeddable_Classes[embeddable class].
The entity contains a single primary key field that is annotated with @EmbeddedId and contains an instance of that embeddable class.
When using this form a separate ID class is not defined because the embeddable class itself can represent complete primary key values.
